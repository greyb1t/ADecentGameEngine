// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VFXSYSTEM_FBS_VFX_H_
#define FLATBUFFERS_GENERATED_VFXSYSTEM_FBS_VFX_H_

#include "flatbuffers/flatbuffers.h"

namespace FBS {
namespace VFX {

struct Quatf;

struct Vec4;

struct Vec3;

struct Vec2;

struct Transform;

struct Particle;
struct ParticleBuilder;

struct BoxProperties;
struct BoxPropertiesBuilder;

struct ConeProperties;
struct ConePropertiesBuilder;

struct SphereProperties;
struct SpherePropertiesBuilder;

struct EmitterGeometry;
struct EmitterGeometryBuilder;

struct Emitter;
struct EmitterBuilder;

struct Key;
struct KeyBuilder;

struct Timeline;
struct TimelineBuilder;

struct ParticleEmitter;
struct ParticleEmitterBuilder;

struct ParticleTimelineKey;
struct ParticleTimelineKeyBuilder;

struct PhysicsParticleTimelineKey;
struct PhysicsParticleTimelineKeyBuilder;

struct PhysicsObjectTimelineKey;
struct PhysicsObjectTimelineKeyBuilder;

struct VFXDescription;
struct VFXDescriptionBuilder;

enum EmitterUnion : uint8_t {
  EmitterUnion_NONE = 0,
  EmitterUnion_ParticleEmitter = 1,
  EmitterUnion_MIN = EmitterUnion_NONE,
  EmitterUnion_MAX = EmitterUnion_ParticleEmitter
};

inline const EmitterUnion (&EnumValuesEmitterUnion())[2] {
  static const EmitterUnion values[] = {
    EmitterUnion_NONE,
    EmitterUnion_ParticleEmitter
  };
  return values;
}

inline const char * const *EnumNamesEmitterUnion() {
  static const char * const names[3] = {
    "NONE",
    "ParticleEmitter",
    nullptr
  };
  return names;
}

inline const char *EnumNameEmitterUnion(EmitterUnion e) {
  if (flatbuffers::IsOutRange(e, EmitterUnion_NONE, EmitterUnion_ParticleEmitter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmitterUnion()[index];
}

template<typename T> struct EmitterUnionTraits {
  static const EmitterUnion enum_value = EmitterUnion_NONE;
};

template<> struct EmitterUnionTraits<FBS::VFX::ParticleEmitter> {
  static const EmitterUnion enum_value = EmitterUnion_ParticleEmitter;
};

bool VerifyEmitterUnion(flatbuffers::Verifier &verifier, const void *obj, EmitterUnion type);
bool VerifyEmitterUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum GeometryProperties : uint8_t {
  GeometryProperties_NONE = 0,
  GeometryProperties_ConeProperties = 1,
  GeometryProperties_SphereProperties = 2,
  GeometryProperties_BoxProperties = 3,
  GeometryProperties_MIN = GeometryProperties_NONE,
  GeometryProperties_MAX = GeometryProperties_BoxProperties
};

inline const GeometryProperties (&EnumValuesGeometryProperties())[4] {
  static const GeometryProperties values[] = {
    GeometryProperties_NONE,
    GeometryProperties_ConeProperties,
    GeometryProperties_SphereProperties,
    GeometryProperties_BoxProperties
  };
  return values;
}

inline const char * const *EnumNamesGeometryProperties() {
  static const char * const names[5] = {
    "NONE",
    "ConeProperties",
    "SphereProperties",
    "BoxProperties",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometryProperties(GeometryProperties e) {
  if (flatbuffers::IsOutRange(e, GeometryProperties_NONE, GeometryProperties_BoxProperties)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometryProperties()[index];
}

template<typename T> struct GeometryPropertiesTraits {
  static const GeometryProperties enum_value = GeometryProperties_NONE;
};

template<> struct GeometryPropertiesTraits<FBS::VFX::ConeProperties> {
  static const GeometryProperties enum_value = GeometryProperties_ConeProperties;
};

template<> struct GeometryPropertiesTraits<FBS::VFX::SphereProperties> {
  static const GeometryProperties enum_value = GeometryProperties_SphereProperties;
};

template<> struct GeometryPropertiesTraits<FBS::VFX::BoxProperties> {
  static const GeometryProperties enum_value = GeometryProperties_BoxProperties;
};

bool VerifyGeometryProperties(flatbuffers::Verifier &verifier, const void *obj, GeometryProperties type);
bool VerifyGeometryPropertiesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quatf FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quatf()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quatf(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Quatf, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Transform FLATBUFFERS_FINAL_CLASS {
 private:
  FBS::VFX::Vec3 position_;
  FBS::VFX::Quatf rotation_;

 public:
  Transform()
      : position_(),
        rotation_() {
  }
  Transform(const FBS::VFX::Vec3 &_position, const FBS::VFX::Quatf &_rotation)
      : position_(_position),
        rotation_(_rotation) {
  }
  const FBS::VFX::Vec3 &position() const {
    return position_;
  }
  const FBS::VFX::Quatf &rotation() const {
    return rotation_;
  }
};
FLATBUFFERS_STRUCT_END(Transform, 28);

struct Particle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParticleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STARTVARIABLES = 4,
    VT_UPDATEVARIABLES = 6,
    VT_TEXTURE = 8,
    VT_MATERIAL = 10,
    VT_COLORSETTING = 12,
    VT_COLOR = 14,
    VT_ENDCOLOR = 16,
    VT_SIZESETTING = 18,
    VT_SIZE = 20,
    VT_ENDSIZE = 22,
    VT_LIFETIME = 24,
    VT_STARTVELOCITY = 26,
    VT_STARTROTATION = 28,
    VT_STARTROTMODIFIER = 30,
    VT_GRAVITY = 32,
    VT_ROTATESPEED = 34,
    VT_ROTATEMODIFIER = 36,
    VT_MATERIALCURVE1 = 38,
    VT_MATERIALCURVE2 = 40,
    VT_MATERIALCURVE3 = 42,
    VT_MATERIALCURVE4 = 44,
    VT_ATTRACTRANGE = 46,
    VT_ATTRACTFORCE = 48,
    VT_ATTRACTCOLLECTDIST = 50,
    VT_SIZECURVE = 52,
    VT_SIZEMODIFIER = 54,
    VT_STARTVELMODIFIER = 56,
    VT_UNITSPERPARTICLE = 58,
    VT_STARTVELSETTINGS = 60,
    VT_UNITSPERPMODIFIER = 62,
    VT_NOISEFORCE = 64,
    VT_NOISESCROLLSPEED = 66,
    VT_NOISESIZE = 68,
    VT_WRAPPOSITION = 70,
    VT_LIFETIMEMOD = 72,
    VT_MAXPARTICLES = 74,
    VT_ATTRACTSETTING = 76,
    VT_NOISESETTING = 78,
    VT_DRAGCONSTANT = 80,
    VT_DRAGAIRDENSITY = 82,
    VT_COLORINTENSITY = 84,
    VT_ACCELERATIONCURVE = 86,
    VT_ACCELERATION = 88,
    VT_ACCELERATIONSETTING = 90
  };
  uint32_t startvariables() const {
    return GetField<uint32_t>(VT_STARTVARIABLES, 0);
  }
  uint32_t updatevariables() const {
    return GetField<uint32_t>(VT_UPDATEVARIABLES, 0);
  }
  const flatbuffers::String *texture() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTURE);
  }
  const flatbuffers::String *material() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIAL);
  }
  uint32_t colorsetting() const {
    return GetField<uint32_t>(VT_COLORSETTING, 0);
  }
  const FBS::VFX::Vec4 *color() const {
    return GetStruct<const FBS::VFX::Vec4 *>(VT_COLOR);
  }
  const FBS::VFX::Vec4 *endcolor() const {
    return GetStruct<const FBS::VFX::Vec4 *>(VT_ENDCOLOR);
  }
  uint32_t sizesetting() const {
    return GetField<uint32_t>(VT_SIZESETTING, 0);
  }
  const FBS::VFX::Vec2 *size() const {
    return GetStruct<const FBS::VFX::Vec2 *>(VT_SIZE);
  }
  const FBS::VFX::Vec2 *endsize() const {
    return GetStruct<const FBS::VFX::Vec2 *>(VT_ENDSIZE);
  }
  float lifetime() const {
    return GetField<float>(VT_LIFETIME, 1.0f);
  }
  float startvelocity() const {
    return GetField<float>(VT_STARTVELOCITY, 0.0f);
  }
  float startrotation() const {
    return GetField<float>(VT_STARTROTATION, 0.0f);
  }
  float startrotmodifier() const {
    return GetField<float>(VT_STARTROTMODIFIER, 0.0f);
  }
  const FBS::VFX::Vec3 *gravity() const {
    return GetStruct<const FBS::VFX::Vec3 *>(VT_GRAVITY);
  }
  float rotatespeed() const {
    return GetField<float>(VT_ROTATESPEED, 0.0f);
  }
  float rotatemodifier() const {
    return GetField<float>(VT_ROTATEMODIFIER, 0.0f);
  }
  const flatbuffers::String *materialcurve1() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALCURVE1);
  }
  const flatbuffers::String *materialcurve2() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALCURVE2);
  }
  const flatbuffers::String *materialcurve3() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALCURVE3);
  }
  const flatbuffers::String *materialcurve4() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALCURVE4);
  }
  float attractrange() const {
    return GetField<float>(VT_ATTRACTRANGE, 100.0f);
  }
  float attractforce() const {
    return GetField<float>(VT_ATTRACTFORCE, 100.0f);
  }
  float attractcollectdist() const {
    return GetField<float>(VT_ATTRACTCOLLECTDIST, 10.0f);
  }
  const flatbuffers::String *sizecurve() const {
    return GetPointer<const flatbuffers::String *>(VT_SIZECURVE);
  }
  const FBS::VFX::Vec2 *sizemodifier() const {
    return GetStruct<const FBS::VFX::Vec2 *>(VT_SIZEMODIFIER);
  }
  float startvelmodifier() const {
    return GetField<float>(VT_STARTVELMODIFIER, 0.0f);
  }
  float unitsperparticle() const {
    return GetField<float>(VT_UNITSPERPARTICLE, 100.0f);
  }
  uint32_t startvelsettings() const {
    return GetField<uint32_t>(VT_STARTVELSETTINGS, 0);
  }
  float unitsperpmodifier() const {
    return GetField<float>(VT_UNITSPERPMODIFIER, 0.0f);
  }
  const FBS::VFX::Vec3 *noiseforce() const {
    return GetStruct<const FBS::VFX::Vec3 *>(VT_NOISEFORCE);
  }
  const FBS::VFX::Vec3 *noisescrollspeed() const {
    return GetStruct<const FBS::VFX::Vec3 *>(VT_NOISESCROLLSPEED);
  }
  float noisesize() const {
    return GetField<float>(VT_NOISESIZE, 1.0f);
  }
  bool wrapposition() const {
    return GetField<uint8_t>(VT_WRAPPOSITION, 0) != 0;
  }
  float lifetimemod() const {
    return GetField<float>(VT_LIFETIMEMOD, 0.0f);
  }
  int32_t maxparticles() const {
    return GetField<int32_t>(VT_MAXPARTICLES, 500);
  }
  uint32_t attractsetting() const {
    return GetField<uint32_t>(VT_ATTRACTSETTING, 0);
  }
  uint32_t noisesetting() const {
    return GetField<uint32_t>(VT_NOISESETTING, 1);
  }
  float dragconstant() const {
    return GetField<float>(VT_DRAGCONSTANT, 1.0f);
  }
  float dragairdensity() const {
    return GetField<float>(VT_DRAGAIRDENSITY, 10000.0f);
  }
  float colorintensity() const {
    return GetField<float>(VT_COLORINTENSITY, 1.0f);
  }
  const flatbuffers::String *accelerationcurve() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCELERATIONCURVE);
  }
  float acceleration() const {
    return GetField<float>(VT_ACCELERATION, 100.0f);
  }
  uint32_t accelerationsetting() const {
    return GetField<uint32_t>(VT_ACCELERATIONSETTING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STARTVARIABLES) &&
           VerifyField<uint32_t>(verifier, VT_UPDATEVARIABLES) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyString(texture()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyField<uint32_t>(verifier, VT_COLORSETTING) &&
           VerifyField<FBS::VFX::Vec4>(verifier, VT_COLOR) &&
           VerifyField<FBS::VFX::Vec4>(verifier, VT_ENDCOLOR) &&
           VerifyField<uint32_t>(verifier, VT_SIZESETTING) &&
           VerifyField<FBS::VFX::Vec2>(verifier, VT_SIZE) &&
           VerifyField<FBS::VFX::Vec2>(verifier, VT_ENDSIZE) &&
           VerifyField<float>(verifier, VT_LIFETIME) &&
           VerifyField<float>(verifier, VT_STARTVELOCITY) &&
           VerifyField<float>(verifier, VT_STARTROTATION) &&
           VerifyField<float>(verifier, VT_STARTROTMODIFIER) &&
           VerifyField<FBS::VFX::Vec3>(verifier, VT_GRAVITY) &&
           VerifyField<float>(verifier, VT_ROTATESPEED) &&
           VerifyField<float>(verifier, VT_ROTATEMODIFIER) &&
           VerifyOffset(verifier, VT_MATERIALCURVE1) &&
           verifier.VerifyString(materialcurve1()) &&
           VerifyOffset(verifier, VT_MATERIALCURVE2) &&
           verifier.VerifyString(materialcurve2()) &&
           VerifyOffset(verifier, VT_MATERIALCURVE3) &&
           verifier.VerifyString(materialcurve3()) &&
           VerifyOffset(verifier, VT_MATERIALCURVE4) &&
           verifier.VerifyString(materialcurve4()) &&
           VerifyField<float>(verifier, VT_ATTRACTRANGE) &&
           VerifyField<float>(verifier, VT_ATTRACTFORCE) &&
           VerifyField<float>(verifier, VT_ATTRACTCOLLECTDIST) &&
           VerifyOffset(verifier, VT_SIZECURVE) &&
           verifier.VerifyString(sizecurve()) &&
           VerifyField<FBS::VFX::Vec2>(verifier, VT_SIZEMODIFIER) &&
           VerifyField<float>(verifier, VT_STARTVELMODIFIER) &&
           VerifyField<float>(verifier, VT_UNITSPERPARTICLE) &&
           VerifyField<uint32_t>(verifier, VT_STARTVELSETTINGS) &&
           VerifyField<float>(verifier, VT_UNITSPERPMODIFIER) &&
           VerifyField<FBS::VFX::Vec3>(verifier, VT_NOISEFORCE) &&
           VerifyField<FBS::VFX::Vec3>(verifier, VT_NOISESCROLLSPEED) &&
           VerifyField<float>(verifier, VT_NOISESIZE) &&
           VerifyField<uint8_t>(verifier, VT_WRAPPOSITION) &&
           VerifyField<float>(verifier, VT_LIFETIMEMOD) &&
           VerifyField<int32_t>(verifier, VT_MAXPARTICLES) &&
           VerifyField<uint32_t>(verifier, VT_ATTRACTSETTING) &&
           VerifyField<uint32_t>(verifier, VT_NOISESETTING) &&
           VerifyField<float>(verifier, VT_DRAGCONSTANT) &&
           VerifyField<float>(verifier, VT_DRAGAIRDENSITY) &&
           VerifyField<float>(verifier, VT_COLORINTENSITY) &&
           VerifyOffset(verifier, VT_ACCELERATIONCURVE) &&
           verifier.VerifyString(accelerationcurve()) &&
           VerifyField<float>(verifier, VT_ACCELERATION) &&
           VerifyField<uint32_t>(verifier, VT_ACCELERATIONSETTING) &&
           verifier.EndTable();
  }
};

struct ParticleBuilder {
  typedef Particle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_startvariables(uint32_t startvariables) {
    fbb_.AddElement<uint32_t>(Particle::VT_STARTVARIABLES, startvariables, 0);
  }
  void add_updatevariables(uint32_t updatevariables) {
    fbb_.AddElement<uint32_t>(Particle::VT_UPDATEVARIABLES, updatevariables, 0);
  }
  void add_texture(flatbuffers::Offset<flatbuffers::String> texture) {
    fbb_.AddOffset(Particle::VT_TEXTURE, texture);
  }
  void add_material(flatbuffers::Offset<flatbuffers::String> material) {
    fbb_.AddOffset(Particle::VT_MATERIAL, material);
  }
  void add_colorsetting(uint32_t colorsetting) {
    fbb_.AddElement<uint32_t>(Particle::VT_COLORSETTING, colorsetting, 0);
  }
  void add_color(const FBS::VFX::Vec4 *color) {
    fbb_.AddStruct(Particle::VT_COLOR, color);
  }
  void add_endcolor(const FBS::VFX::Vec4 *endcolor) {
    fbb_.AddStruct(Particle::VT_ENDCOLOR, endcolor);
  }
  void add_sizesetting(uint32_t sizesetting) {
    fbb_.AddElement<uint32_t>(Particle::VT_SIZESETTING, sizesetting, 0);
  }
  void add_size(const FBS::VFX::Vec2 *size) {
    fbb_.AddStruct(Particle::VT_SIZE, size);
  }
  void add_endsize(const FBS::VFX::Vec2 *endsize) {
    fbb_.AddStruct(Particle::VT_ENDSIZE, endsize);
  }
  void add_lifetime(float lifetime) {
    fbb_.AddElement<float>(Particle::VT_LIFETIME, lifetime, 1.0f);
  }
  void add_startvelocity(float startvelocity) {
    fbb_.AddElement<float>(Particle::VT_STARTVELOCITY, startvelocity, 0.0f);
  }
  void add_startrotation(float startrotation) {
    fbb_.AddElement<float>(Particle::VT_STARTROTATION, startrotation, 0.0f);
  }
  void add_startrotmodifier(float startrotmodifier) {
    fbb_.AddElement<float>(Particle::VT_STARTROTMODIFIER, startrotmodifier, 0.0f);
  }
  void add_gravity(const FBS::VFX::Vec3 *gravity) {
    fbb_.AddStruct(Particle::VT_GRAVITY, gravity);
  }
  void add_rotatespeed(float rotatespeed) {
    fbb_.AddElement<float>(Particle::VT_ROTATESPEED, rotatespeed, 0.0f);
  }
  void add_rotatemodifier(float rotatemodifier) {
    fbb_.AddElement<float>(Particle::VT_ROTATEMODIFIER, rotatemodifier, 0.0f);
  }
  void add_materialcurve1(flatbuffers::Offset<flatbuffers::String> materialcurve1) {
    fbb_.AddOffset(Particle::VT_MATERIALCURVE1, materialcurve1);
  }
  void add_materialcurve2(flatbuffers::Offset<flatbuffers::String> materialcurve2) {
    fbb_.AddOffset(Particle::VT_MATERIALCURVE2, materialcurve2);
  }
  void add_materialcurve3(flatbuffers::Offset<flatbuffers::String> materialcurve3) {
    fbb_.AddOffset(Particle::VT_MATERIALCURVE3, materialcurve3);
  }
  void add_materialcurve4(flatbuffers::Offset<flatbuffers::String> materialcurve4) {
    fbb_.AddOffset(Particle::VT_MATERIALCURVE4, materialcurve4);
  }
  void add_attractrange(float attractrange) {
    fbb_.AddElement<float>(Particle::VT_ATTRACTRANGE, attractrange, 100.0f);
  }
  void add_attractforce(float attractforce) {
    fbb_.AddElement<float>(Particle::VT_ATTRACTFORCE, attractforce, 100.0f);
  }
  void add_attractcollectdist(float attractcollectdist) {
    fbb_.AddElement<float>(Particle::VT_ATTRACTCOLLECTDIST, attractcollectdist, 10.0f);
  }
  void add_sizecurve(flatbuffers::Offset<flatbuffers::String> sizecurve) {
    fbb_.AddOffset(Particle::VT_SIZECURVE, sizecurve);
  }
  void add_sizemodifier(const FBS::VFX::Vec2 *sizemodifier) {
    fbb_.AddStruct(Particle::VT_SIZEMODIFIER, sizemodifier);
  }
  void add_startvelmodifier(float startvelmodifier) {
    fbb_.AddElement<float>(Particle::VT_STARTVELMODIFIER, startvelmodifier, 0.0f);
  }
  void add_unitsperparticle(float unitsperparticle) {
    fbb_.AddElement<float>(Particle::VT_UNITSPERPARTICLE, unitsperparticle, 100.0f);
  }
  void add_startvelsettings(uint32_t startvelsettings) {
    fbb_.AddElement<uint32_t>(Particle::VT_STARTVELSETTINGS, startvelsettings, 0);
  }
  void add_unitsperpmodifier(float unitsperpmodifier) {
    fbb_.AddElement<float>(Particle::VT_UNITSPERPMODIFIER, unitsperpmodifier, 0.0f);
  }
  void add_noiseforce(const FBS::VFX::Vec3 *noiseforce) {
    fbb_.AddStruct(Particle::VT_NOISEFORCE, noiseforce);
  }
  void add_noisescrollspeed(const FBS::VFX::Vec3 *noisescrollspeed) {
    fbb_.AddStruct(Particle::VT_NOISESCROLLSPEED, noisescrollspeed);
  }
  void add_noisesize(float noisesize) {
    fbb_.AddElement<float>(Particle::VT_NOISESIZE, noisesize, 1.0f);
  }
  void add_wrapposition(bool wrapposition) {
    fbb_.AddElement<uint8_t>(Particle::VT_WRAPPOSITION, static_cast<uint8_t>(wrapposition), 0);
  }
  void add_lifetimemod(float lifetimemod) {
    fbb_.AddElement<float>(Particle::VT_LIFETIMEMOD, lifetimemod, 0.0f);
  }
  void add_maxparticles(int32_t maxparticles) {
    fbb_.AddElement<int32_t>(Particle::VT_MAXPARTICLES, maxparticles, 500);
  }
  void add_attractsetting(uint32_t attractsetting) {
    fbb_.AddElement<uint32_t>(Particle::VT_ATTRACTSETTING, attractsetting, 0);
  }
  void add_noisesetting(uint32_t noisesetting) {
    fbb_.AddElement<uint32_t>(Particle::VT_NOISESETTING, noisesetting, 1);
  }
  void add_dragconstant(float dragconstant) {
    fbb_.AddElement<float>(Particle::VT_DRAGCONSTANT, dragconstant, 1.0f);
  }
  void add_dragairdensity(float dragairdensity) {
    fbb_.AddElement<float>(Particle::VT_DRAGAIRDENSITY, dragairdensity, 10000.0f);
  }
  void add_colorintensity(float colorintensity) {
    fbb_.AddElement<float>(Particle::VT_COLORINTENSITY, colorintensity, 1.0f);
  }
  void add_accelerationcurve(flatbuffers::Offset<flatbuffers::String> accelerationcurve) {
    fbb_.AddOffset(Particle::VT_ACCELERATIONCURVE, accelerationcurve);
  }
  void add_acceleration(float acceleration) {
    fbb_.AddElement<float>(Particle::VT_ACCELERATION, acceleration, 100.0f);
  }
  void add_accelerationsetting(uint32_t accelerationsetting) {
    fbb_.AddElement<uint32_t>(Particle::VT_ACCELERATIONSETTING, accelerationsetting, 0);
  }
  explicit ParticleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Particle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Particle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Particle> CreateParticle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t startvariables = 0,
    uint32_t updatevariables = 0,
    flatbuffers::Offset<flatbuffers::String> texture = 0,
    flatbuffers::Offset<flatbuffers::String> material = 0,
    uint32_t colorsetting = 0,
    const FBS::VFX::Vec4 *color = 0,
    const FBS::VFX::Vec4 *endcolor = 0,
    uint32_t sizesetting = 0,
    const FBS::VFX::Vec2 *size = 0,
    const FBS::VFX::Vec2 *endsize = 0,
    float lifetime = 1.0f,
    float startvelocity = 0.0f,
    float startrotation = 0.0f,
    float startrotmodifier = 0.0f,
    const FBS::VFX::Vec3 *gravity = 0,
    float rotatespeed = 0.0f,
    float rotatemodifier = 0.0f,
    flatbuffers::Offset<flatbuffers::String> materialcurve1 = 0,
    flatbuffers::Offset<flatbuffers::String> materialcurve2 = 0,
    flatbuffers::Offset<flatbuffers::String> materialcurve3 = 0,
    flatbuffers::Offset<flatbuffers::String> materialcurve4 = 0,
    float attractrange = 100.0f,
    float attractforce = 100.0f,
    float attractcollectdist = 10.0f,
    flatbuffers::Offset<flatbuffers::String> sizecurve = 0,
    const FBS::VFX::Vec2 *sizemodifier = 0,
    float startvelmodifier = 0.0f,
    float unitsperparticle = 100.0f,
    uint32_t startvelsettings = 0,
    float unitsperpmodifier = 0.0f,
    const FBS::VFX::Vec3 *noiseforce = 0,
    const FBS::VFX::Vec3 *noisescrollspeed = 0,
    float noisesize = 1.0f,
    bool wrapposition = false,
    float lifetimemod = 0.0f,
    int32_t maxparticles = 500,
    uint32_t attractsetting = 0,
    uint32_t noisesetting = 1,
    float dragconstant = 1.0f,
    float dragairdensity = 10000.0f,
    float colorintensity = 1.0f,
    flatbuffers::Offset<flatbuffers::String> accelerationcurve = 0,
    float acceleration = 100.0f,
    uint32_t accelerationsetting = 0) {
  ParticleBuilder builder_(_fbb);
  builder_.add_accelerationsetting(accelerationsetting);
  builder_.add_acceleration(acceleration);
  builder_.add_accelerationcurve(accelerationcurve);
  builder_.add_colorintensity(colorintensity);
  builder_.add_dragairdensity(dragairdensity);
  builder_.add_dragconstant(dragconstant);
  builder_.add_noisesetting(noisesetting);
  builder_.add_attractsetting(attractsetting);
  builder_.add_maxparticles(maxparticles);
  builder_.add_lifetimemod(lifetimemod);
  builder_.add_noisesize(noisesize);
  builder_.add_noisescrollspeed(noisescrollspeed);
  builder_.add_noiseforce(noiseforce);
  builder_.add_unitsperpmodifier(unitsperpmodifier);
  builder_.add_startvelsettings(startvelsettings);
  builder_.add_unitsperparticle(unitsperparticle);
  builder_.add_startvelmodifier(startvelmodifier);
  builder_.add_sizemodifier(sizemodifier);
  builder_.add_sizecurve(sizecurve);
  builder_.add_attractcollectdist(attractcollectdist);
  builder_.add_attractforce(attractforce);
  builder_.add_attractrange(attractrange);
  builder_.add_materialcurve4(materialcurve4);
  builder_.add_materialcurve3(materialcurve3);
  builder_.add_materialcurve2(materialcurve2);
  builder_.add_materialcurve1(materialcurve1);
  builder_.add_rotatemodifier(rotatemodifier);
  builder_.add_rotatespeed(rotatespeed);
  builder_.add_gravity(gravity);
  builder_.add_startrotmodifier(startrotmodifier);
  builder_.add_startrotation(startrotation);
  builder_.add_startvelocity(startvelocity);
  builder_.add_lifetime(lifetime);
  builder_.add_endsize(endsize);
  builder_.add_size(size);
  builder_.add_sizesetting(sizesetting);
  builder_.add_endcolor(endcolor);
  builder_.add_color(color);
  builder_.add_colorsetting(colorsetting);
  builder_.add_material(material);
  builder_.add_texture(texture);
  builder_.add_updatevariables(updatevariables);
  builder_.add_startvariables(startvariables);
  builder_.add_wrapposition(wrapposition);
  return builder_.Finish();
}

inline flatbuffers::Offset<Particle> CreateParticleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t startvariables = 0,
    uint32_t updatevariables = 0,
    const char *texture = nullptr,
    const char *material = nullptr,
    uint32_t colorsetting = 0,
    const FBS::VFX::Vec4 *color = 0,
    const FBS::VFX::Vec4 *endcolor = 0,
    uint32_t sizesetting = 0,
    const FBS::VFX::Vec2 *size = 0,
    const FBS::VFX::Vec2 *endsize = 0,
    float lifetime = 1.0f,
    float startvelocity = 0.0f,
    float startrotation = 0.0f,
    float startrotmodifier = 0.0f,
    const FBS::VFX::Vec3 *gravity = 0,
    float rotatespeed = 0.0f,
    float rotatemodifier = 0.0f,
    const char *materialcurve1 = nullptr,
    const char *materialcurve2 = nullptr,
    const char *materialcurve3 = nullptr,
    const char *materialcurve4 = nullptr,
    float attractrange = 100.0f,
    float attractforce = 100.0f,
    float attractcollectdist = 10.0f,
    const char *sizecurve = nullptr,
    const FBS::VFX::Vec2 *sizemodifier = 0,
    float startvelmodifier = 0.0f,
    float unitsperparticle = 100.0f,
    uint32_t startvelsettings = 0,
    float unitsperpmodifier = 0.0f,
    const FBS::VFX::Vec3 *noiseforce = 0,
    const FBS::VFX::Vec3 *noisescrollspeed = 0,
    float noisesize = 1.0f,
    bool wrapposition = false,
    float lifetimemod = 0.0f,
    int32_t maxparticles = 500,
    uint32_t attractsetting = 0,
    uint32_t noisesetting = 1,
    float dragconstant = 1.0f,
    float dragairdensity = 10000.0f,
    float colorintensity = 1.0f,
    const char *accelerationcurve = nullptr,
    float acceleration = 100.0f,
    uint32_t accelerationsetting = 0) {
  auto texture__ = texture ? _fbb.CreateString(texture) : 0;
  auto material__ = material ? _fbb.CreateString(material) : 0;
  auto materialcurve1__ = materialcurve1 ? _fbb.CreateString(materialcurve1) : 0;
  auto materialcurve2__ = materialcurve2 ? _fbb.CreateString(materialcurve2) : 0;
  auto materialcurve3__ = materialcurve3 ? _fbb.CreateString(materialcurve3) : 0;
  auto materialcurve4__ = materialcurve4 ? _fbb.CreateString(materialcurve4) : 0;
  auto sizecurve__ = sizecurve ? _fbb.CreateString(sizecurve) : 0;
  auto accelerationcurve__ = accelerationcurve ? _fbb.CreateString(accelerationcurve) : 0;
  return FBS::VFX::CreateParticle(
      _fbb,
      startvariables,
      updatevariables,
      texture__,
      material__,
      colorsetting,
      color,
      endcolor,
      sizesetting,
      size,
      endsize,
      lifetime,
      startvelocity,
      startrotation,
      startrotmodifier,
      gravity,
      rotatespeed,
      rotatemodifier,
      materialcurve1__,
      materialcurve2__,
      materialcurve3__,
      materialcurve4__,
      attractrange,
      attractforce,
      attractcollectdist,
      sizecurve__,
      sizemodifier,
      startvelmodifier,
      unitsperparticle,
      startvelsettings,
      unitsperpmodifier,
      noiseforce,
      noisescrollspeed,
      noisesize,
      wrapposition,
      lifetimemod,
      maxparticles,
      attractsetting,
      noisesetting,
      dragconstant,
      dragairdensity,
      colorintensity,
      accelerationcurve__,
      acceleration,
      accelerationsetting);
}

struct BoxProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoxPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOXHALFSIZE = 4
  };
  const FBS::VFX::Vec3 *boxhalfsize() const {
    return GetStruct<const FBS::VFX::Vec3 *>(VT_BOXHALFSIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<FBS::VFX::Vec3>(verifier, VT_BOXHALFSIZE) &&
           verifier.EndTable();
  }
};

struct BoxPropertiesBuilder {
  typedef BoxProperties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boxhalfsize(const FBS::VFX::Vec3 *boxhalfsize) {
    fbb_.AddStruct(BoxProperties::VT_BOXHALFSIZE, boxhalfsize);
  }
  explicit BoxPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoxProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoxProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoxProperties> CreateBoxProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    const FBS::VFX::Vec3 *boxhalfsize = 0) {
  BoxPropertiesBuilder builder_(_fbb);
  builder_.add_boxhalfsize(boxhalfsize);
  return builder_.Finish();
}

struct ConeProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConePropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGLE = 4,
    VT_RADIUS = 6
  };
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 45.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           verifier.EndTable();
  }
};

struct ConePropertiesBuilder {
  typedef ConeProperties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angle(float angle) {
    fbb_.AddElement<float>(ConeProperties::VT_ANGLE, angle, 0.0f);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ConeProperties::VT_RADIUS, radius, 45.0f);
  }
  explicit ConePropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConeProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConeProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConeProperties> CreateConeProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    float angle = 0.0f,
    float radius = 45.0f) {
  ConePropertiesBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_angle(angle);
  return builder_.Finish();
}

struct SphereProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpherePropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_MINRADIUS = 6
  };
  float radius() const {
    return GetField<float>(VT_RADIUS, 100.0f);
  }
  float minradius() const {
    return GetField<float>(VT_MINRADIUS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_MINRADIUS) &&
           verifier.EndTable();
  }
};

struct SpherePropertiesBuilder {
  typedef SphereProperties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(float radius) {
    fbb_.AddElement<float>(SphereProperties::VT_RADIUS, radius, 100.0f);
  }
  void add_minradius(float minradius) {
    fbb_.AddElement<float>(SphereProperties::VT_MINRADIUS, minradius, 0.0f);
  }
  explicit SpherePropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SphereProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphereProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphereProperties> CreateSphereProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    float radius = 100.0f,
    float minradius = 0.0f) {
  SpherePropertiesBuilder builder_(_fbb);
  builder_.add_minradius(minradius);
  builder_.add_radius(radius);
  return builder_.Finish();
}

struct EmitterGeometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmitterGeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMETRYTYPE = 4,
    VT_PROPERTIES_TYPE = 6,
    VT_PROPERTIES = 8,
    VT_EMITFROMTYPE = 10,
    VT_EMITDIRECTIONTYPE = 12,
    VT_ROTATION = 14
  };
  uint32_t geometrytype() const {
    return GetField<uint32_t>(VT_GEOMETRYTYPE, 0);
  }
  FBS::VFX::GeometryProperties properties_type() const {
    return static_cast<FBS::VFX::GeometryProperties>(GetField<uint8_t>(VT_PROPERTIES_TYPE, 0));
  }
  const void *properties() const {
    return GetPointer<const void *>(VT_PROPERTIES);
  }
  template<typename T> const T *properties_as() const;
  const FBS::VFX::ConeProperties *properties_as_ConeProperties() const {
    return properties_type() == FBS::VFX::GeometryProperties_ConeProperties ? static_cast<const FBS::VFX::ConeProperties *>(properties()) : nullptr;
  }
  const FBS::VFX::SphereProperties *properties_as_SphereProperties() const {
    return properties_type() == FBS::VFX::GeometryProperties_SphereProperties ? static_cast<const FBS::VFX::SphereProperties *>(properties()) : nullptr;
  }
  const FBS::VFX::BoxProperties *properties_as_BoxProperties() const {
    return properties_type() == FBS::VFX::GeometryProperties_BoxProperties ? static_cast<const FBS::VFX::BoxProperties *>(properties()) : nullptr;
  }
  uint32_t emitfromtype() const {
    return GetField<uint32_t>(VT_EMITFROMTYPE, 0);
  }
  uint32_t emitdirectiontype() const {
    return GetField<uint32_t>(VT_EMITDIRECTIONTYPE, 0);
  }
  const FBS::VFX::Quatf *rotation() const {
    return GetStruct<const FBS::VFX::Quatf *>(VT_ROTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GEOMETRYTYPE) &&
           VerifyField<uint8_t>(verifier, VT_PROPERTIES_TYPE) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           VerifyGeometryProperties(verifier, properties(), properties_type()) &&
           VerifyField<uint32_t>(verifier, VT_EMITFROMTYPE) &&
           VerifyField<uint32_t>(verifier, VT_EMITDIRECTIONTYPE) &&
           VerifyField<FBS::VFX::Quatf>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::VFX::ConeProperties *EmitterGeometry::properties_as<FBS::VFX::ConeProperties>() const {
  return properties_as_ConeProperties();
}

template<> inline const FBS::VFX::SphereProperties *EmitterGeometry::properties_as<FBS::VFX::SphereProperties>() const {
  return properties_as_SphereProperties();
}

template<> inline const FBS::VFX::BoxProperties *EmitterGeometry::properties_as<FBS::VFX::BoxProperties>() const {
  return properties_as_BoxProperties();
}

struct EmitterGeometryBuilder {
  typedef EmitterGeometry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geometrytype(uint32_t geometrytype) {
    fbb_.AddElement<uint32_t>(EmitterGeometry::VT_GEOMETRYTYPE, geometrytype, 0);
  }
  void add_properties_type(FBS::VFX::GeometryProperties properties_type) {
    fbb_.AddElement<uint8_t>(EmitterGeometry::VT_PROPERTIES_TYPE, static_cast<uint8_t>(properties_type), 0);
  }
  void add_properties(flatbuffers::Offset<void> properties) {
    fbb_.AddOffset(EmitterGeometry::VT_PROPERTIES, properties);
  }
  void add_emitfromtype(uint32_t emitfromtype) {
    fbb_.AddElement<uint32_t>(EmitterGeometry::VT_EMITFROMTYPE, emitfromtype, 0);
  }
  void add_emitdirectiontype(uint32_t emitdirectiontype) {
    fbb_.AddElement<uint32_t>(EmitterGeometry::VT_EMITDIRECTIONTYPE, emitdirectiontype, 0);
  }
  void add_rotation(const FBS::VFX::Quatf *rotation) {
    fbb_.AddStruct(EmitterGeometry::VT_ROTATION, rotation);
  }
  explicit EmitterGeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmitterGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmitterGeometry>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmitterGeometry> CreateEmitterGeometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t geometrytype = 0,
    FBS::VFX::GeometryProperties properties_type = FBS::VFX::GeometryProperties_NONE,
    flatbuffers::Offset<void> properties = 0,
    uint32_t emitfromtype = 0,
    uint32_t emitdirectiontype = 0,
    const FBS::VFX::Quatf *rotation = 0) {
  EmitterGeometryBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_emitdirectiontype(emitdirectiontype);
  builder_.add_emitfromtype(emitfromtype);
  builder_.add_properties(properties);
  builder_.add_geometrytype(geometrytype);
  builder_.add_properties_type(properties_type);
  return builder_.Finish();
}

struct Emitter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmitterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMETRY = 4,
    VT_TIMELINE = 6,
    VT_TRANSFORM = 8,
    VT_DURATION = 10,
    VT_SPACE = 12,
    VT_KEEPALIVE = 14
  };
  const FBS::VFX::EmitterGeometry *geometry() const {
    return GetPointer<const FBS::VFX::EmitterGeometry *>(VT_GEOMETRY);
  }
  const FBS::VFX::Timeline *timeline() const {
    return GetPointer<const FBS::VFX::Timeline *>(VT_TIMELINE);
  }
  const FBS::VFX::Transform *transform() const {
    return GetStruct<const FBS::VFX::Transform *>(VT_TRANSFORM);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 1.0f);
  }
  uint32_t space() const {
    return GetField<uint32_t>(VT_SPACE, 0);
  }
  bool keepalive() const {
    return GetField<uint8_t>(VT_KEEPALIVE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyTable(geometry()) &&
           VerifyOffset(verifier, VT_TIMELINE) &&
           verifier.VerifyTable(timeline()) &&
           VerifyField<FBS::VFX::Transform>(verifier, VT_TRANSFORM) &&
           VerifyField<float>(verifier, VT_DURATION) &&
           VerifyField<uint32_t>(verifier, VT_SPACE) &&
           VerifyField<uint8_t>(verifier, VT_KEEPALIVE) &&
           verifier.EndTable();
  }
};

struct EmitterBuilder {
  typedef Emitter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geometry(flatbuffers::Offset<FBS::VFX::EmitterGeometry> geometry) {
    fbb_.AddOffset(Emitter::VT_GEOMETRY, geometry);
  }
  void add_timeline(flatbuffers::Offset<FBS::VFX::Timeline> timeline) {
    fbb_.AddOffset(Emitter::VT_TIMELINE, timeline);
  }
  void add_transform(const FBS::VFX::Transform *transform) {
    fbb_.AddStruct(Emitter::VT_TRANSFORM, transform);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(Emitter::VT_DURATION, duration, 1.0f);
  }
  void add_space(uint32_t space) {
    fbb_.AddElement<uint32_t>(Emitter::VT_SPACE, space, 0);
  }
  void add_keepalive(bool keepalive) {
    fbb_.AddElement<uint8_t>(Emitter::VT_KEEPALIVE, static_cast<uint8_t>(keepalive), 1);
  }
  explicit EmitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Emitter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Emitter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Emitter> CreateEmitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::VFX::EmitterGeometry> geometry = 0,
    flatbuffers::Offset<FBS::VFX::Timeline> timeline = 0,
    const FBS::VFX::Transform *transform = 0,
    float duration = 1.0f,
    uint32_t space = 0,
    bool keepalive = true) {
  EmitterBuilder builder_(_fbb);
  builder_.add_space(space);
  builder_.add_duration(duration);
  builder_.add_transform(transform);
  builder_.add_timeline(timeline);
  builder_.add_geometry(geometry);
  builder_.add_keepalive(keepalive);
  return builder_.Finish();
}

struct Key FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_TIMERANDOM = 6,
    VT_AMOUNT = 8,
    VT_AMOUNTRANDOM = 10,
    VT_LOOPING = 12,
    VT_REPEATTIMES = 14,
    VT_REPEATDELAY = 16,
    VT_REPEATDELAYRANDOM = 18,
    VT_LOOPTIMESPERSECOND = 20
  };
  float time() const {
    return GetField<float>(VT_TIME, 0.0f);
  }
  float timerandom() const {
    return GetField<float>(VT_TIMERANDOM, 0.0f);
  }
  uint32_t amount() const {
    return GetField<uint32_t>(VT_AMOUNT, 1);
  }
  uint32_t amountrandom() const {
    return GetField<uint32_t>(VT_AMOUNTRANDOM, 0);
  }
  bool looping() const {
    return GetField<uint8_t>(VT_LOOPING, 0) != 0;
  }
  uint32_t repeattimes() const {
    return GetField<uint32_t>(VT_REPEATTIMES, 0);
  }
  float repeatdelay() const {
    return GetField<float>(VT_REPEATDELAY, 0.1f);
  }
  float repeatdelayrandom() const {
    return GetField<float>(VT_REPEATDELAYRANDOM, 0.0f);
  }
  float looptimespersecond() const {
    return GetField<float>(VT_LOOPTIMESPERSECOND, 40.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIME) &&
           VerifyField<float>(verifier, VT_TIMERANDOM) &&
           VerifyField<uint32_t>(verifier, VT_AMOUNT) &&
           VerifyField<uint32_t>(verifier, VT_AMOUNTRANDOM) &&
           VerifyField<uint8_t>(verifier, VT_LOOPING) &&
           VerifyField<uint32_t>(verifier, VT_REPEATTIMES) &&
           VerifyField<float>(verifier, VT_REPEATDELAY) &&
           VerifyField<float>(verifier, VT_REPEATDELAYRANDOM) &&
           VerifyField<float>(verifier, VT_LOOPTIMESPERSECOND) &&
           verifier.EndTable();
  }
};

struct KeyBuilder {
  typedef Key Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(float time) {
    fbb_.AddElement<float>(Key::VT_TIME, time, 0.0f);
  }
  void add_timerandom(float timerandom) {
    fbb_.AddElement<float>(Key::VT_TIMERANDOM, timerandom, 0.0f);
  }
  void add_amount(uint32_t amount) {
    fbb_.AddElement<uint32_t>(Key::VT_AMOUNT, amount, 1);
  }
  void add_amountrandom(uint32_t amountrandom) {
    fbb_.AddElement<uint32_t>(Key::VT_AMOUNTRANDOM, amountrandom, 0);
  }
  void add_looping(bool looping) {
    fbb_.AddElement<uint8_t>(Key::VT_LOOPING, static_cast<uint8_t>(looping), 0);
  }
  void add_repeattimes(uint32_t repeattimes) {
    fbb_.AddElement<uint32_t>(Key::VT_REPEATTIMES, repeattimes, 0);
  }
  void add_repeatdelay(float repeatdelay) {
    fbb_.AddElement<float>(Key::VT_REPEATDELAY, repeatdelay, 0.1f);
  }
  void add_repeatdelayrandom(float repeatdelayrandom) {
    fbb_.AddElement<float>(Key::VT_REPEATDELAYRANDOM, repeatdelayrandom, 0.0f);
  }
  void add_looptimespersecond(float looptimespersecond) {
    fbb_.AddElement<float>(Key::VT_LOOPTIMESPERSECOND, looptimespersecond, 40.0f);
  }
  explicit KeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Key> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Key>(end);
    return o;
  }
};

inline flatbuffers::Offset<Key> CreateKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f,
    float timerandom = 0.0f,
    uint32_t amount = 1,
    uint32_t amountrandom = 0,
    bool looping = false,
    uint32_t repeattimes = 0,
    float repeatdelay = 0.1f,
    float repeatdelayrandom = 0.0f,
    float looptimespersecond = 40.0f) {
  KeyBuilder builder_(_fbb);
  builder_.add_looptimespersecond(looptimespersecond);
  builder_.add_repeatdelayrandom(repeatdelayrandom);
  builder_.add_repeatdelay(repeatdelay);
  builder_.add_repeattimes(repeattimes);
  builder_.add_amountrandom(amountrandom);
  builder_.add_amount(amount);
  builder_.add_timerandom(timerandom);
  builder_.add_time(time);
  builder_.add_looping(looping);
  return builder_.Finish();
}

struct Timeline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimelineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::Key>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::Key>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct TimelineBuilder {
  typedef Timeline Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::Key>>> keys) {
    fbb_.AddOffset(Timeline::VT_KEYS, keys);
  }
  explicit TimelineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Timeline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Timeline>(end);
    return o;
  }
};

inline flatbuffers::Offset<Timeline> CreateTimeline(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::Key>>> keys = 0) {
  TimelineBuilder builder_(_fbb);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<Timeline> CreateTimelineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FBS::VFX::Key>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<FBS::VFX::Key>>(*keys) : 0;
  return FBS::VFX::CreateTimeline(
      _fbb,
      keys__);
}

struct ParticleEmitter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParticleEmitterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EMITTER = 4,
    VT_PARTICLE = 6
  };
  const FBS::VFX::Emitter *emitter() const {
    return GetPointer<const FBS::VFX::Emitter *>(VT_EMITTER);
  }
  const FBS::VFX::Particle *particle() const {
    return GetPointer<const FBS::VFX::Particle *>(VT_PARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EMITTER) &&
           verifier.VerifyTable(emitter()) &&
           VerifyOffset(verifier, VT_PARTICLE) &&
           verifier.VerifyTable(particle()) &&
           verifier.EndTable();
  }
};

struct ParticleEmitterBuilder {
  typedef ParticleEmitter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_emitter(flatbuffers::Offset<FBS::VFX::Emitter> emitter) {
    fbb_.AddOffset(ParticleEmitter::VT_EMITTER, emitter);
  }
  void add_particle(flatbuffers::Offset<FBS::VFX::Particle> particle) {
    fbb_.AddOffset(ParticleEmitter::VT_PARTICLE, particle);
  }
  explicit ParticleEmitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParticleEmitter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParticleEmitter>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParticleEmitter> CreateParticleEmitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::VFX::Emitter> emitter = 0,
    flatbuffers::Offset<FBS::VFX::Particle> particle = 0) {
  ParticleEmitterBuilder builder_(_fbb);
  builder_.add_particle(particle);
  builder_.add_emitter(emitter);
  return builder_.Finish();
}

struct ParticleTimelineKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParticleTimelineKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_PARTICLEEMITTER = 6
  };
  const FBS::VFX::Key *key() const {
    return GetPointer<const FBS::VFX::Key *>(VT_KEY);
  }
  const FBS::VFX::ParticleEmitter *particleemitter() const {
    return GetPointer<const FBS::VFX::ParticleEmitter *>(VT_PARTICLEEMITTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           VerifyOffset(verifier, VT_PARTICLEEMITTER) &&
           verifier.VerifyTable(particleemitter()) &&
           verifier.EndTable();
  }
};

struct ParticleTimelineKeyBuilder {
  typedef ParticleTimelineKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<FBS::VFX::Key> key) {
    fbb_.AddOffset(ParticleTimelineKey::VT_KEY, key);
  }
  void add_particleemitter(flatbuffers::Offset<FBS::VFX::ParticleEmitter> particleemitter) {
    fbb_.AddOffset(ParticleTimelineKey::VT_PARTICLEEMITTER, particleemitter);
  }
  explicit ParticleTimelineKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParticleTimelineKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParticleTimelineKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParticleTimelineKey> CreateParticleTimelineKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::VFX::Key> key = 0,
    flatbuffers::Offset<FBS::VFX::ParticleEmitter> particleemitter = 0) {
  ParticleTimelineKeyBuilder builder_(_fbb);
  builder_.add_particleemitter(particleemitter);
  builder_.add_key(key);
  return builder_.Finish();
}

struct PhysicsParticleTimelineKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PhysicsParticleTimelineKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const FBS::VFX::Key *key() const {
    return GetPointer<const FBS::VFX::Key *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           verifier.EndTable();
  }
};

struct PhysicsParticleTimelineKeyBuilder {
  typedef PhysicsParticleTimelineKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<FBS::VFX::Key> key) {
    fbb_.AddOffset(PhysicsParticleTimelineKey::VT_KEY, key);
  }
  explicit PhysicsParticleTimelineKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PhysicsParticleTimelineKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PhysicsParticleTimelineKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<PhysicsParticleTimelineKey> CreatePhysicsParticleTimelineKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::VFX::Key> key = 0) {
  PhysicsParticleTimelineKeyBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

struct PhysicsObjectTimelineKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PhysicsObjectTimelineKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const FBS::VFX::Key *key() const {
    return GetPointer<const FBS::VFX::Key *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           verifier.EndTable();
  }
};

struct PhysicsObjectTimelineKeyBuilder {
  typedef PhysicsObjectTimelineKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<FBS::VFX::Key> key) {
    fbb_.AddOffset(PhysicsObjectTimelineKey::VT_KEY, key);
  }
  explicit PhysicsObjectTimelineKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PhysicsObjectTimelineKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PhysicsObjectTimelineKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<PhysicsObjectTimelineKey> CreatePhysicsObjectTimelineKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::VFX::Key> key = 0) {
  PhysicsObjectTimelineKeyBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

struct VFXDescription FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VFXDescriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTICLEEMITTERS = 4,
    VT_TITLE = 6,
    VT_SPACE = 8,
    VT_DURATION = 10,
    VT_LOOPING = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::ParticleTimelineKey>> *particleemitters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::ParticleTimelineKey>> *>(VT_PARTICLEEMITTERS);
  }
  const flatbuffers::String *title() const {
    return GetPointer<const flatbuffers::String *>(VT_TITLE);
  }
  uint32_t space() const {
    return GetField<uint32_t>(VT_SPACE, 0);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 1.0f);
  }
  bool looping() const {
    return GetField<uint8_t>(VT_LOOPING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARTICLEEMITTERS) &&
           verifier.VerifyVector(particleemitters()) &&
           verifier.VerifyVectorOfTables(particleemitters()) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyField<uint32_t>(verifier, VT_SPACE) &&
           VerifyField<float>(verifier, VT_DURATION) &&
           VerifyField<uint8_t>(verifier, VT_LOOPING) &&
           verifier.EndTable();
  }
};

struct VFXDescriptionBuilder {
  typedef VFXDescription Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_particleemitters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::ParticleTimelineKey>>> particleemitters) {
    fbb_.AddOffset(VFXDescription::VT_PARTICLEEMITTERS, particleemitters);
  }
  void add_title(flatbuffers::Offset<flatbuffers::String> title) {
    fbb_.AddOffset(VFXDescription::VT_TITLE, title);
  }
  void add_space(uint32_t space) {
    fbb_.AddElement<uint32_t>(VFXDescription::VT_SPACE, space, 0);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(VFXDescription::VT_DURATION, duration, 1.0f);
  }
  void add_looping(bool looping) {
    fbb_.AddElement<uint8_t>(VFXDescription::VT_LOOPING, static_cast<uint8_t>(looping), 0);
  }
  explicit VFXDescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VFXDescription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VFXDescription>(end);
    return o;
  }
};

inline flatbuffers::Offset<VFXDescription> CreateVFXDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::VFX::ParticleTimelineKey>>> particleemitters = 0,
    flatbuffers::Offset<flatbuffers::String> title = 0,
    uint32_t space = 0,
    float duration = 1.0f,
    bool looping = false) {
  VFXDescriptionBuilder builder_(_fbb);
  builder_.add_duration(duration);
  builder_.add_space(space);
  builder_.add_title(title);
  builder_.add_particleemitters(particleemitters);
  builder_.add_looping(looping);
  return builder_.Finish();
}

inline flatbuffers::Offset<VFXDescription> CreateVFXDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FBS::VFX::ParticleTimelineKey>> *particleemitters = nullptr,
    const char *title = nullptr,
    uint32_t space = 0,
    float duration = 1.0f,
    bool looping = false) {
  auto particleemitters__ = particleemitters ? _fbb.CreateVector<flatbuffers::Offset<FBS::VFX::ParticleTimelineKey>>(*particleemitters) : 0;
  auto title__ = title ? _fbb.CreateString(title) : 0;
  return FBS::VFX::CreateVFXDescription(
      _fbb,
      particleemitters__,
      title__,
      space,
      duration,
      looping);
}

inline bool VerifyEmitterUnion(flatbuffers::Verifier &verifier, const void *obj, EmitterUnion type) {
  switch (type) {
    case EmitterUnion_NONE: {
      return true;
    }
    case EmitterUnion_ParticleEmitter: {
      auto ptr = reinterpret_cast<const FBS::VFX::ParticleEmitter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEmitterUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEmitterUnion(
        verifier,  values->Get(i), types->GetEnum<EmitterUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGeometryProperties(flatbuffers::Verifier &verifier, const void *obj, GeometryProperties type) {
  switch (type) {
    case GeometryProperties_NONE: {
      return true;
    }
    case GeometryProperties_ConeProperties: {
      auto ptr = reinterpret_cast<const FBS::VFX::ConeProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryProperties_SphereProperties: {
      auto ptr = reinterpret_cast<const FBS::VFX::SphereProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryProperties_BoxProperties: {
      auto ptr = reinterpret_cast<const FBS::VFX::BoxProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGeometryPropertiesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeometryProperties(
        verifier,  values->Get(i), types->GetEnum<GeometryProperties>(i))) {
      return false;
    }
  }
  return true;
}

inline const FBS::VFX::VFXDescription *GetVFXDescription(const void *buf) {
  return flatbuffers::GetRoot<FBS::VFX::VFXDescription>(buf);
}

inline const FBS::VFX::VFXDescription *GetSizePrefixedVFXDescription(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FBS::VFX::VFXDescription>(buf);
}

inline bool VerifyVFXDescriptionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FBS::VFX::VFXDescription>(nullptr);
}

inline bool VerifySizePrefixedVFXDescriptionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FBS::VFX::VFXDescription>(nullptr);
}

inline void FinishVFXDescriptionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::VFX::VFXDescription> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedVFXDescriptionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::VFX::VFXDescription> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace VFX
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_VFXSYSTEM_FBS_VFX_H_
